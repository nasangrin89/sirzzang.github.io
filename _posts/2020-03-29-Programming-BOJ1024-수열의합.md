---
title: "[백준] BOJ1024 수열의 합"
excerpt: 1일 1문제풀이 10일차
header:
  teaser: /assets/images/blog-Programming.jpg
toc: true
categories:
  - Programming
tags:
  - BOJ
  - Python
  - Programming
  - Programmers
  - 수학
  - 탐색
use_math: true
---





> [문제 출처](https://www.acmicpc.net/problem/1024)



# 1. 문제



N과 L이 주어질 때, 합이 N이면서, 길이가 적어도 L인 가장 짧은 연속된 음이 아닌 정수 리스트를 구하는 프로그램을 작성하시오.



**입력**

첫째 줄에 N과 L이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이고, L은 2보다 크거나 같고, 100보다 작거나 같은 자연수이다.



**출력**

만약 리스트의 길이가 100보다 작거나 같으면, 연속된 수를 첫째 줄에 공백으로 구분하여 출력한다. 만약 길이가 100보다 크거나 그러한 수열이 없을 때는 -1을 출력한다.



**입출력 예**

```python
입력 : 18 2
출력 : 5 6 7
```



---



# 2. 나의 풀이 



## 풀이 방법



 연속된 수를 구해야 하므로, **공차가 1인 등차수열**을 반환하면 된다. 문제의 조건에 따르면, 공차가 1이면서 다음의 세 가지 사항을 만족하는 등차수열을 구하면 된다.

* 출력할 등차수열의 합이 `N`과 같아야 하고,
* 출력할 등차수열의 길이는 `L` 이상 100 이어야 하며,
* 그 중에서도 최소 길이여야 한다.



 초항이 `a`이고, 공차가 `d`이며, 길이가 `n`인 등차수열의 합은 다음과 같다.
$$
S = \frac {n(2a+(n-1))} 2
$$


 위의 공식에 따라 길이가 2이상일 때 공차가 1인 등차수열의 *합* 을 나열하고, 길이와 합 간의 규칙을 찾는다.

| 길이 | 등차수열의 합 |
| :--: | :-----------: |
|  2   |  S = 2a + 1   |
|  3   |  S = 3a + 3   |
|  4   |  S = 4a + 6   |
|  5   |  S = 5a + 10  |
|  6   |  S = 6a + 15  |

 길이가 **홀수**일 때는 수열의 합이 해당 길이의 *배수* 이다. 길이가 **짝수**일 때는 수열의 합을 길이로 *modula 연산한 값이 길이를 2로 나눈 몫* 이 된다.  **따라서, 입력받은 `L`부터 100 이하인 수 중에서, 위의 조건을 만족할 때, 수열의 초항을 구하고, 그 초항부터 해당 길이만큼의 수를 출력하면 된다.** 일단 조건을 만족할 때의 `L`을 구하면, 초항은 쉽다. 공차가 1인 등차수열의 합을 나타낸 위의 수식을 변형하면, 초항은 다음과 같다.  아래 식의 n에 `L`을, S에 `N`을 대입하기만 하면 된다.
$$
a = \frac {2S - n(n-1)} {2n}
$$


 L이 100이 될 때까지 조건을 검사했는데 맞는 게 아무 것도 없다면, 그 때는 `-1`을 출력한다.



> *시행 착오*
>
>  처음에 등차수열이라는 생각을 하지 않고, 길이가 홀수일 때와 짝수일 때, 합이 홀수일 때와 짝수일 때 등등 여러 경우를 나눠 가며 조건을 분기시키다가 시간을 보냈다. 이 문제가 수학으로 분류된 까닭이 있었는데도 불구하고 아주 바보같이 접근했다.



## 풀이 코드

* 초항을 위의 식으로 구하지 않고, 길이가 2가 될 때부터 써 가며 규칙을 찾았다. 사용한 방법을 굳이 다시 언급하지는 않겠다.
* 100까지 검사했음에도 안 되는 경우를 구현하기 위해 `for ~ else` 구문을 사용했다.
* 채점해 보니 몇 가지 예외가 있었다.
  * 초항이 음수면 안 된다. 초항이 음수가 나오는 경우, 길이를 늘려서 다시 구하도록 하는 조건을 추가한다.
  * 초항이 실수여도 안 된다. 초항이 실수가 나오는 경우, 길이를 늘려 다시 구하도록 했다.
* 출력 형식에 주의하자.

```python
import sys

N, L = map(int, sys.stdin.readline().rstrip().split())

# L부터 100까지 검사.
for l in range(L, 101):
    if N % l == 0 or N % l == (l//2):
        if (N-(l**2-l)//2)/l != (N-(l**2-l)//2)//l or (N-(l**2-l)//2)//l < 0: # 초항이 실수이거나 음수이면 안 되는 조건.
            continue
        
        # 조건에 만족하는 길이가 있다면,
        for i in range(l):
            print((N-(l**2-l)//2)//l + i, end=" ")
            break

else:
    print(-1)
```





---



# 3. 다른 풀이



[풀이 출처](https://www.acmicpc.net/source/12598433)

```python
N, L = map(int, input().split())
can = False
while L<101:
    temp = N-L*(L-1)//2
    if temp<0:
        can = True
        break
    if temp%L == 0:
        temp //= L
        ans = [temp+x for x in range(L)]
        break
    L+=1
if L>100 or can:
    ans = [-1]
print(*ans)
```



# 4. 배운 점, 더 생각해 볼 점



* 정말 다시 또 한 번 느낀다. 경우를 계속해서 나누는 것은 좋지 않다. 조건문을 너무 분기시키지 말자.
* 내 코드는 왜 항상 지저분해 보일까?