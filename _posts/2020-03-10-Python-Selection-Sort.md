---
title:  "[알고리즘] 정렬 알고리즘(Sort Algorithm)"
excerpt:
header:
  teaser: /assets/images/blog-Programming.jpg

categories:
  - Python
toc : true
tags:
  - Python
  - 알고리즘
  - 정렬
  - 선택정렬
---





---





# 파이썬으로 구현하는 알고리즘_선택 정렬



## 선택 정렬



  선택 정렬은 주어진 자료 중 가장 작은(혹은 가장 큰) 값의 원소부터 차례대로 선택하여 위치를 교환해 나간다. 학교 다닐 때 키순서대로 줄을 섰던 것을 떠올리면 된다. 가장 작은(혹은 가장 큰) 수부터 정렬하기 시작하여 위치를 교환하는 정렬 알고리즘이다.



 이를 적용하기 위해 먼저 셀렉션 알고리즘에 대해 알아보자.





### 셀렉션 알고리즘



 셀렉션 알고리즘은 자료에서 k번째로 큰(혹은 작은) 원소를 찾는 알고리즘으로, 최솟값, 최댓값 혹은 중간값을 찾을 때 주로 적용한다.



**코드 구현**

* 1번째부터 k번째 순번까지 작은 원소들을 찾아 list의 앞쪽으로 이동시킨다.
* list의 k번째 원소를 반환한다.

```python
def SelectAlgorithm(list, k):
    for i in range(k): # k번째 순번까지
        min_idx = i
        for j in range(i+1, len(list)): # 뒤의 원소가 앞의 원소보다 크다면 
            if list[min_idx] > list[j]: # 최소 idx 교체.
                min_idx = j 
        list[i], list[min_idx] = list[min_idx], list[i] # i번째와 자리 바꿈.
    return list[k-1] # k번째로 작은 수 반환
```



 위와 같은 셀렉션 알고리즘을 전체 자료에 k = 1로 생각하고 적용하면, 그것이 바로 선택 정렬이다. 



![selection sort]({{site.url}}/assets/images/Selection-Sort.gif){:.aligncenter}

<center><sup>이미지 출처 : https://www.fun-coding.org/Chapter12-selectionsorting.html</sup></center>



 정렬을 수행하는 방법은 다음과 같다.

1. 주어진 리스트에서 최솟값(혹은 최댓값)을 찾는다.
2. 그 값을 리스트의 맨 앞 값과 교환한다. 리스트에서 맨 앞 원소는 정렬이 완료된다.
3. 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.



*예) 64 25 10 22 11을 오름차순으로 선택정렬하는 과정*

**정렬 원소** 미정렬원소

|       리스트       | 최솟값 | 맨 앞 |     정렬 결과      |
| :----------------: | :----: | :---: | :----------------: |
|   64 25 10 22 11   |   10   |  64   | **10** 25 64 22 11 |
| **10** 25 64 22 11 |   11   |  25   | **10 11** 64 22 25 |
| **10 11** 64 22 25 |   22   |  64   | **10 11 22** 64 25 |
| **10 11 22** 64 25 |   25   |  64   | **10 11 22 25 64** |



**시간 복잡도**

 총 **O(N^2)**의 시간 복잡도를 가진다. 

 앞에서부터 한 칸씩 진행하고, 한 칸씩 진행할 때마다 전체 칸을 돌아야 하기 때문이다. 즉,  반복문을 통해 모든 인덱스의 값에 접근해야 하기 때문에 기본적으로 O(N)의 시간복잡도를 갖는다. 또한 하나의 루프 안에서 현재 인덱스의 값과 다른 인덱스의 값을 비교하여 최솟값을 찾아야 하므로, 인덱스 위치에 따라 또 O(N)의 시간을 필요로 한다.



**코드 구현**

* 뒷 순번의 인덱스로 갈수록 비교할 범위가 줄어든다.
* 안쪽 반복문에서는 현재 인덱스부터 마지막 인덱스까지 최솟값의 인덱스를 찾아내고, 바깥쪽 반복문에서 최솟값의 인덱스와 현재 인덱스에 있는 값을 교환한다.

```python
def SelectionSort(a):
    for i in range(len(a)-1):
        min_idx = i
        # 최솟값 인덱스 찾기
        for j in range(i+1, len(a)):
            if a[min_idx] > a[j]:
                min_idx = j
        # 최솟값 인덱스의 값과 위치 바꾸기
        a[i], a[min_idx] = a[min_idx], a[i]
    return a
```



## 삽입 정렬



 자료 내 모든 원소들을 앞에서부터 차례대로 이미 정렬된 부분과 비교하여, 자신의 위치를 찾아냄으로써 정렬을 완성하는 알고리즘이다. 도서관 사서가 책을 정렬할 때 일반적으로 활용되는 정렬 방식이다.

 사람의 머리로 이해하기는 간단하지만, 코드로 구현했을 때 효율성이 떨어진다.



![insertion sort]({{site.url}}/assets/images/insertion-sort.gif){:.aligncenter}

<center><sup>출처 : http://ejklike.github.io/2017/03/04/sorting-algorithms-with-python.html</sup></center>



 정렬을 수행하는 방법은 다음과 같다.

1. 정렬할 자료를 부분집합 S, U로 나눈다.
   * S : 이미 정렬된 앞 부분 원소들. 초기 상태에는 첫 번째 원소를 S로 간주한다.
   * U : 아직 정렬되지 않은 나머지 원소들.
2. U의 원소들을 하나씩 꺼내서 S의 마지막 원소부터 비교하면서 위치를 찾는다.
3. 2의 과정을 반복하며, S의 원소는 하나씩 늘리고 U의 원소는 하나씩 감소시킨다.
4. U가 공집합이 되면 모든 삽입정렬 과정이 완료된다.



*예) 69 10 30 2 16 8 31 22를 오름차순으로 삽입정렬하는 과정*

**정렬 원소** 미정렬원소

| S              | U                  | 위치                               | 정렬 결과                 |
| -------------- | ------------------ | ---------------------------------- | ------------------------- |
| **69**         | 10 30 2 16 8 31 22 | 10 < 69                            | **10 69** 30 2 16 8 31 22 |
| **10 69**      | 30 2 16 8 31 22    | 30 < 69,<br />30 > 10              | **10 30 69** 2 16 8 31 22 |
| **10 30 69**   | 2 16 8 31 22       | 2 < 69,<br />2 < 30,<br />2 < 10   | **2 10 30 69** 16 8 31 22 |
| **2 10 30 69** | 16 8 31 22         | 16 < 39,<br />16 < 30,<br />16 > 2 | **2 10 16 30 69** 8 31 22 |
| ...            | ...                | ...                                | ...                       |



**시간 복잡도**

 각 부분집합의 원소를 매번 비교해야 하므로, **O(N^2)**의 시간 복잡도를 가진다. 다만, 평균적으로 버블정렬보다는 빠르다.

 데이터가 이미 정렬되어 있는 경우라면 O(N)의 시간 복잡도를 보이지만, 역순으로 정렬된 경우 삽입을 위해 값을 하나씩 밀어내야 하는 과정을 반복해야 하므로  매우 느리다. 



**코드 구현**

* 내부 반복문에서는 새롭게 추가된 값보다 작은 숫자를 만나는 최초의 순간까지 뒤에서부터 비교하며, 앞의 값이 뒤의 값보다 클 경우 자리를 바꾼다. 앞에서 뒤로 진행한다.
  * 앞에 있는 숫자들은 기존에 정렬을 해 놓았기 때문에, 최초로 작은 숫자를 만난다면 앞으로 갈 필요가 없다.
  * 값을 바꿀 때는 버블정렬처럼 swap하지 않고, 값의 위치를 shift한다. 즉, 앞의 값을 뒤로 밀다가 최초로 작은 값을 만난 순간 추가되는 값을 넣는다.
* 외부 반복문에서는 정렬 범위를 2에서 끝까지 확대해 나간다. 뒤에서 앞으로 진행한다. *버블 정렬과 달리* 정렬 범위가 넓어진다.

```python
def InsertionSort(a):
    for end in range(1, len(a)):
        to_insert = a[end] # 비교하려는 값.
        i = end # 비교하려는 값의 인덱스.
        while i > 0 and a[i-1] > to_insert:
            arr[i] = arr[i-1]
            i -= 1
        arr[i] = to_insert
```



## 퀵 정렬



 분할 정복 방식을 적용해 정렬을 진행하는 알고리즘이다.

 리스트 중 하나를 피봇으로 선택하고, 피봇보다 *작은* 원소는 **왼쪽**에, *큰* 원소는 **오른쪽**에 정렬한다. 이후 피봇값을 중심으로 리스트를 **분할**하고, 분할된 각각의 리스트에 재귀적으로 이 과정을 반복한다.

 이렇게 작은 쪽의 배열, 큰 쪽의 배열 각각에 대해 정렬 과정을 반복하다 보면 각각의 파티션에 정렬된 파티션이 두 개밖에 남지 않게 된다. 이는 정렬이 완료되었음을 의미하며, 각각의 리스트를 작은 리스트로 분할하여 모든 정렬을 완료함으로써 정렬 문제를 **정복**하게 된다.



![quick sort]({{site.url}}/assets/images/quick-sort.png){: width="70%" height="60%"}{:.aligncenter}

<center><sup>이미지 출처 : https://www.fun-coding.org/Chapter12-selectionsorting.html</sup></center>

한 단계가 완료될 때마다 피봇의 위치가 확정된다.





**정렬 원소** {미정렬 원소}

| 정렬 대상 리스트      | 피봇 | L    | R    | 정렬 결과                                                    |
| --------------------- | ---- | ---- | ---- | ------------------------------------------------------------ |
| 68 11 29 3 15 9 32 23 | 3    | 68   | 68   | **3** {11 29 68 15 9 32 23}<br />1. L = R = 68이므로 68과 피봇 교환.<br />2. 피봇 3의 위치 확정.<br />3. 피봇 3의 왼쪽은 공집합이므로 ,오른쪽에 대해서만 이후 정렬 수행. |
| 11 29 68 15 9 32 23   | 15   | 29   | 9    | **3** {11 9 68 15 29 32 23}<br />1. L과 R이 만나지 않았으므로 위의 작업 반복. |
|                       | 15   | 68   | 68   | **3** {11 9} **15** {68 29 32 23} <br />1. L = R = 68이므로 68과 피봇 교환.<br />2. 피봇 15의 위치 확정.<br />3. 피봇 왼쪽과 오른쪽에 대해 정렬 수행 |
| 11 9                  | 11   |      |      | **3** {9} **11 15** {68 29 32 23}<br />1. L의 원소가 그 자체로 피봇이므로, 그 자체로 교환이 일어난 것으로 간주.<br />2. 피봇 11의 위치 확정.<br /> |
| 9                     | 9    |      |      | **3 9 11 15** {68 29 32 23}<br />1. 피봇 9의 위치 확정.      |
| 68 29 32 23           | 29   | 68   | 23   | **3 9 11 15** {23 29 32 68}<br />1. L과 R이 만나지 않았으므로 위의 작업 반복 |
|                       | 29   | 29   | 29   | **3 9 11 15** {23} **29** {32 68}<br /> 1. R의 원소가 그 자체로 피봇이므로 자리 교환 발생.<br />2. 피봇 29의 위치 확정. |
| 23                    | 23   |      |      | **3 9 11 15 23 29** {32 68}<br />1. 피봇 23의 위치 확정.     |
| 32 68                 | 32   | 32   | 32   | **3 9 11 15 23 29 32** {68}<br />1. L = R = 32이므로 피봇 32의 위치 확정. |
| 68                    | 68   |      |      | **3 9 11 15 23 29 32 68**<br />1. 피봇 68의 위치 확정.       |



**시간 복잡도**

 평균적으로**O(NlogN)**의 시간 복잡도를 가진다. 

 파티션 안 원소의 개수가 1이 될 때까지 분할하기 때문에, 파티션으로 분할하는 횟수는  N번이다. 따라서 O(N)의 시간을 필요로 한다. 그러나, 한 번 분할할 때마다 탐색해야 할 데이터가 절반씩 줄어들기 때문에 한 번 돌 때 탐색을 위해서는 O(logN)의 시간을 필요로 한다.

 그러나 최악의 경우 **O(N^2)**의 시간 복잡도를 가진다.

 이는 피봇의 왼쪽 요소가 매 번 하나가 되도록 피봇이 선택되는 경우에 발생한다. 이 경우, 우선 N번의 데이터 분할을 진행하여 O(N)의 시간이 필요하다. 이후, N개의 요소에 대해 모두 정렬을 수행해야 하기 때문에 추가적으로 O(N)의 시간이 필요하게 되는 것이다. 피봇을 어떻게 선택하느냐에 따라 탐색 및 분할에 소요되는 시간이 결정되기 때문에 피봇의 선택이 매우 중요한 정렬 알고리즘이다.

|                    최선의 경우 : O(nlogn)                    |                     최악의 경우 : O(n^2)                     |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![best]({{site.url}}/assets/images/sort-time-complexity-etc1.png) | ![worst]({{site.url}}/assets/images/sort-time-complexity-etc2.png) |

<center><sup>퀵 정렬 시간 복잡도(출처 : https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html)</sup></center>

 *그럼에도 불구하고, 퀵 정렬은 평균 시간 복잡도가 매우 우수하기 때문에 가장 자주 사용된다.*

 따라서 피봇 값을 선택할 때 시간 복잡도를 낮출 수 있는 방식을 사용하는 것이 좋다. ㅇ컨대, 1) 정해진 위치가 아니라 랜덤하게 피봇값을 선택하거나, 2) 몇 개의 값을 샘플링해 중앙값에 가까운 피봇을 선택하거나, 3) 배열의 첫 값과 중앙값, 그리고 마지막 값 중 크기가 중간인 값을 사용할 수 있다.



 

**코드 구현**

 배열의 **중앙에 있는 값**을 피봇으로 선택해 구현하는 방식을 선택한다.

* in-place 방식 : 정렬과 파티션, 2개의 내부 함수로 나눈다.
  * 정렬 함수는 재귀 함수로, 정렬 범위의 시작 인덱스와 끝 인덱스를 인자로 받는다.
  * 파티션 함수는 정렬할 범위를 인자로 받아 피봇의 값을 구한다. 이 함수 내에서는 피봇의 좌우측 값들을 정렬하고, 분할 기준점의 인덱스를 피봇으로서 반환한다.
    * 왼쪽 인덱스(L)를 계속해서 증가시키고, 오른쪽 인덱스(R)를 계속해서 감소시키기 위한 while문을 작성한다. while문은 두 인덱스가 서로 만날 때까지 반복된다.
      * 왼쪽(L)에서 오른쪽(R)으로 이동하며 피봇과 비교해 피봇보다 큰 값의 인덱스를 찾는다.(*피봇보다 큰데 좌측에 있는 값을 찾는다.*)
      * 오른쪽(R)에서 왼쪽(L)으로 이동하며 피봇과 비교해 피봇보다 작거나 같은 값을 찾는다.(*피봇보다 작은데 우측에 있는 값을 찾는다.*)
      * 두 인덱스가 서로 만나지 않는다면, 왼쪽(L) 인덱스의 값과 오른쪽 인덱스(R)의 값의 위치를 바꾼다.
    * 두 인덱스가 만나 while문을 빠져나오면, 다음 재귀 호출의 기준점이 될 시작 인덱스(L)를 반환한다.

```python
def QuickSort(a, begin, end):
    if begin < end :
        p = Partition(a, begin, end) # 분할 기준 인덱스
        QuickSort(a, begin, p-1) # 왼쪽 배열에 대해 재귀 호출
        QuickSort(a, p+1, end) # 오른쪽 배열에 대해 재귀 호출
    return a
        
def Partition(a, begin, end):
    pivot_idx = (begin + end) // 2 # 피봇 인덱스 : 중간 위치로 설정.
    print(a[pivot_idx]) # 피봇 값 확인 위해
    L = begin
    R = end
    while L < R: # L이랑 R 만날 때까지 아래 과정 반복
        while (a[L] < a[pivot_idx] and L < R) : # 피봇 값보다 왼쪽에 있는데 작다면 L 증가 = 피봇값보다 크거나 같은데 왼쪽에 있는 원소 찾기.
            L += 1
        while (a[R] >= a[pivot_idx] and L < R) : # 피봇 값보다 오른 쪽에 있는데 크다면 R 증가 = 피봇값보다 작은데 오른쪽에 있는 원소 찾기.
            R -= 1
        if L < R : # 위의 과정을 거쳤는데 만나지 않은 경우
            if L == pivot_idx : # L이 피봇 값이면
                pivot_idx = R # 피봇을 오른쪽으로 바꾸기
            a[L], a[R] = a[R], a[L] # 만나지 않았다면, L과 R 위치의 원소 바꾸기
    a[pivot_idx], a[R] = a[R], a[pivot_idx]
    return R
```



 위와 같은 내용을 아래와 같이 구현할 수도 있다.

```python
def QuickSort(a, begin, end):
	if begin < end :
    	p = Partition(a, begin, end)
   		QuickSort(a, begin, p-1)
    	QuickSort(a, p+1, end) # 인덱스 체크하기
	return a

def Partition(a, begin, end):
    pivot_idx = (begin + end) // 2 # 피봇 인덱스
    L = begin
    R = end
    while L < R:
        while (a[L] < a[pivot_idx] and L < R) :
            L += 1
        while (a[R] >= a[pivot_idx] and L < R) :
            R -= 1
        if L < R :
            if L == pivot_idx :
                pivot_idx = R
            a[L], a[R] = a[R], a[L]
    a[pivot_idx], a[R] = a[R], a[pivot_idx]
    return R 
```



* 조금 더 간결하고 이해하기 쉬운 구현을 적용하면 다음과 같다. 그러나, 이 방식은 매 번 재귀 호출을 진행할 때마다 새로운 리스트를 생성하기 때문에, 메모리 사용 측면에서 매우 비효율적이다. 따라서 원리만 이해하고 넘어가도록 한다.
  * 피봇보다 작은 값, 동일한 값, 큰 값을 저장할 3개의 리스트를 생성한다.
  * 반복문을 통해 각 값과 피봇 값을 비교한 후, 해당하는 리스트에 추가한다.
  * 작은 값과 큰 값을 담고 있는 왼쪽과 오른쪽의 배열을 대상으로, 퀵 정렬 함수를 재귀적으로 호출한다.
  * 재귀 호출의 결과를 크기 순으로 합쳐 정렬된 리스트를 얻는다.

```python
def QuickSort(a):
    if len(a) <= 1:
        return a
    # 피봇 선택
    pivot = arr[len(arr)//2]
    lesser_a, equal_a, greater_a = [], [], []
    for num in a:
        if num < pivot:
            lesser_a.append(num)
        elif num > pivot:
            greater_a.append(num)
        else:
            equal_a.append(num)
    return QuickSort(lesser_a) + equal_a + QuickSort(greater_a)
```





## 병합 정렬



여러 정렬된 자료의 집합을 병합해ㅔ 한 개의 정렬된 집합으로 만듦.

분할정복 알고리즘 활용

자료를 최소 단위 문제까지 나눈 후 차례대로 정렬하여 최종 결과를 얻음. top-down 접근 방식.

O(nlogn)

연결 리스트 사용해 구현.



동작 과정

1. 분할 : 전체 자료 집합을 최소 부분집합이 될 때까지 분할 작업 계속 진행.

(그림)

2. 병합 : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합. 모든 부분집합이 1개로 병합될 때까지 반복.

(그림)



69 10 30 2 16 8 31 22를 병합 정렬하는 과정

분할

전체 자료 집합에 대해 최소 크기 부분집합이 될 때까지 분할 작업 계속 : 크기가 1인 부분집합이 될 때까지 : 69 10 30 2 16 8 31 22

병합

2개의 부분집합을 정렬하면서 하나의 집합으로 병합

10 69 / 2 30/ 8 16/ 22 31/

2 10 30 69/ 8 16 22 31

2 8 10 16 22 30 31 69





알고리즘

분할: 재귀 호출 과정에서는 리스트의 길이가 1인 경우와 아닌 경우를 구분. 리스트의 경우가 1이면 종료 조건으로 입력된 리스트 그대로 반환. 길이가 1이 될 때까지 병합정렬 재귀 호출.

그렇지 않다면 분할에서 오른쪽과 왼쪽에 대해 재귀 호출.

그 결과로 반환된 리스트는 정렬된 상태가 된다.

두 개의 리스트를 머지 함수를 이용해 하나의 리스트로 반환.



```python
def MergeSort(a):
    if len(a) <= 1: # 사이즈가 0이나 1인 경우 바로 리턴.
        return a
    
    # 1. 분할 부분
    mid = len(a)//2
    left = a[:mid]
    right = a[mid:]
    # 리스트의 길이가 1이 될 때까지 재귀 호출
    left = MergeSort(left)
    right = MergeSort(right)
    
    # 2. 정복 부분 : 분할된 리스트 병합
    return Merge(left, right)
```



병합

병합 과정 구현 시 사용되는 리스트 자료 구조로는 배열리스트와 연결리스트가 있음. 배열 사용 시 분리/병합 과정에서 빈번한 자료 비교 연산과 이동 연산 발생으로 비효율적. 따라서 연결 리스트로 구현함으로써 배열 사용시 단점 극복하여 효과적인 극복 가능.



연결 리스트로 저장된 자료들에 대한 병합 과정

```python
def Merge(left, right):
    result = [] # 두 개의 분할된 리스트를 병합하여 result를 만듦.
    
    while len(left) > 0 and len(right) > 0 : # 양 쪽 리스트에 원소가 남아 있다면
        # 두 하위 리스트의 첫 원소를 비교해 작은 것부터 result에 추가.
        if left[0] <= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
            
    if len(left) > 0 : # 왼쪽 리스트에 원소 남아 있으면
        result.extend(left)
    if len(right) > 0 : # 오른쪽 리스트에 원소 남아 있으면
        result.extend(right)
        
    return result
```













## 카운팅 정렬(a.k.a 계수 정렬)



 원소를 직접 비교하지 않고, 원소들의 개수를 세어 정렬하는 방식이다. 즉, 항목의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 센다.

 

![카운팅정렬]({{site.url}}/assets/images/counting-sort.png){:.aligncenter}

<center><sup>이미지 출처 : https://m.blog.naver.com/PostView.nhn?blogId=dnpc7848&logNo=221439395086&categoryNo=15&proxyReferer=https%3A%2F%2Fwww.google.com%2F</sup></center>



 정렬을 수행하는 방법은 다음과 같다.

1. 항목의 개수를 저장할 **COUNTS 배열**을 만든다. 
   * 이 때 COUNTS를 세기 위한 충분한 공간을 할당하려면, 주어진  집합에서 가장 큰 정수를 알아야 한다.
   * 또한 COUNTS는 정수 항목들로 직접 인덱스되는 배열이어야 한다.
2. 주어진 자료 집합(DATA)에서 **각 항목 i가 총 몇 개 있는지** 세고, **COUNTS의 i번째 칸에 저장**한다.
3. COUNTS에서 앞에서 뒤로 가며, i번째 칸의 숫자를 i+1번째 칸에 누적한다. 이 조정 작업이 완료되면, COUNTS 배열의 값은 정렬 후 반환할 배열 TEMP에서 인덱스가 나타내는 i라는 항목이 TEMP 배열의 몇 번째 칸에 들어가야 하는지 보여준다.
4. 주어진 집합 DATA의 마지막 항목부터 정렬한다.
   * 정렬해야 할 각 항목의 값을 i라고 한다.
   * COUNTS의 i번째 칸에 있는 수를 room_number한다.
   * TEMP의 room_number칸에 i를 삽입한다.
   * COUNTS의 i번째 칸에 있는 수를 1 감소시킨다.



*예) 0 4 1 3 1 2 4 1를 오름차순으로 카운팅정렬하는 과정*

- DATA : [0 4 1 3 1 2 4 1]

- COUNTS : [1 4 5 6 8]

  - 조정 전 COUNTS : [1 3 1 1 2]
  - 조정 전 COUNTS의 인덱스는 DATA의 항목을 나타내며, 값은 각 항목이 등장한 횟수를 의미한다.

  

<sub>파이썬의 리스트 인덱스가 0부터 시작해서 헷갈릴 수 있다. 여기서 COUNTS[i]는 TEMP의 몇 번째 칸인지를 의미한다고 생각하자</sub>

| i(정렬할 항목) | COUNTS[i] |      TEMP       | 정렬 후 COUNTS |
| :------------: | :-------: | :-------------: | :------------: |
|       1        |     4     | _ _ _ 1 _ _ _ _ |   1 3 5 6 8    |
|       4        |     8     | _ _ _ 1 _ _ _ 4 |   1 3 5 6 7    |
|       2        |     5     |  _ _ _ 1 2 _ 4  |   1 3 4 6 7    |
|       1        |     3     | _ _ 1 1 2 _ _ 4 |   1 2 4 6 7    |
|       3        |     6     | _ _ 1 1 2 3 _ 4 |   1 2 4 5 7    |
|       1        |     2     | _ 1 1 1 2 3 _ 4 |   1 1 4 5 7    |
|       4        |     7     | _ 1 1 1 2 3 4 4 |   1 1 4 5 6    |
|       0        |     1     | 0 1 1 1 2 3 4 4 |   0 1 4 5 6    |





**코드 구현**

* 바깥쪽 반복문에 의해 안쪽 반복문의 범위가 제어된다.
* 한 단계를 마치면 마지막에 정렬이 종료된 원소가 위차하므로, 단계를 거칠수록 정렬의 범위가 1씩 작아진다.

```python
def CountingSort(A):

    counts = [0] * (max(A)+1)
    temp = [0] * len(A)

    # 개수 세서 COUNTS에 저장.
    for a in A:
        counts[a] += 1 # 인덱스로 구현한다면 for i in A: C[A[i]] += 1와 동일.
        
    # COUNTS 조정.
    for i in range(len(counts)-1):
        counts[i+1] += counts[i]
    
    for i in range(len(temp)-1, -1, -1): # reversed(range(len(TEMP)))와 동일
        temp[counts[A[i]]-1] = A[i]
        counts[A[i]] -= 1
    
    return temp
```



**시간 복잡도**

 시간 복잡도는 O(n+k)로, n은 배열할 항목의 수, k는 항목 중 최댓값을 의미한다. 

 만약 항목 중 최댓값이 n보다 작으면 시간 복잡도는 O(n)에 가까워지지만, 극단적인 예로 k가 매우 큰 수이면 O(무한)이 될 수도 있다. 따라서 정렬할 수의 최댓값에 영향을 받는 알고리즘이라고 볼 수 있다.



**특징**

  이전까지의 알고리즘과 달리 처음으로 단 한 번의 비교도 수행하지 않고 정렬을 진행하는 알고리즘이다. 그러나 숫자를 세서 저장할 공간이 필요하므로, 메모리 낭비가 야기될 수 있다. 예컨대, 만약 배열이 0, 1, 2, 3, 10억이라면, COUNTS로 (10억+1)칸을 만들어야 한다.



**활용**

* 정수나, 정수로 표현될 수 있는 자료에 대해서 적용한다. 위의 구현 과정을 통해 살펴보았듯, 정수 항목으로 인덱스되는 발생 횟수들의 리스트를 사용하기 때문이다. 
* 원소들의 개수를 세어 정렬하기 때문에, 중복값이 많이 분포되어 있는 배열을 정렬할 때 효과적으로 작용한다.
* 또한, 시간복잡도를 지배하는 것이 배열의 최댓값이기 때문에 정렬할 항목들이 특정한 범위 안에 존재하는 경우 사용한다.

 카운팅 정렬을 사용하는 대표적인 예는, 26개의 알파벳으로 이루어진 문자열에서 Suffix Array를 얻는 경우다.



















최악의 시간 복잡도는 O(n^2)으로 합병 정렬에 비해 효율이 좋지 못함.

그러나 퀵 정렬인 이유는, 평균 복잡도가 nlogn이기 때문.























|        | 합병 정렬                             | 퀵 정렬                                                      |
| ------ | ------------------------------------- | ------------------------------------------------------------ |
| 공통점 | 두 개로 분할해 각각 정렬              | 두 개로 분할해 각각 정렬                                     |
| 차이점 | 분할 시 단순히 두 부분으로 나눔.      | 분할 시, 기준 아이템을 중심으로 작은 것은 왼편, 큰 것은 오른 편에 위치. |
|        | 각 부분 정렬 후 합병 후처리작업 필요. | 정렬 후 후처리 작업 필요 업슴.                               |

