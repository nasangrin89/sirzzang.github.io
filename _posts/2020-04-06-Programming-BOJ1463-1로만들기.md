---
title: "[백준] 1로 만들기"
excerpt: 1일 1문제풀이 17일차
header:
  teaser: /assets/images/blog-Programming.jpg
toc: true
categories:
  - Programming
tags:
  - BOJ
  - Python
  - Programming
  - DP

---





> [문제 출처](https://www.acmicpc.net/problem/1463)



# 1. 문제



정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.



**입력**

첫째 줄에 1보다 크거나 같고, 10**6보다 작거나 같은 정수 N이 주어진다.



**출력**

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.



**입출력 예**

```python
입력
2
출력
1
입력
10
출력
3
```



---

# 2. 나의 풀이 



## 풀이 방법



 주어진 연산의 종류를 고려한다면, N번째 수를 1로 만드는 연산은 다음의 세 가지 경우가 있을 수 있다.

- N-1번째 수를 1로 만드는 데에 필요한 연산의 수 + 1 : N에서 1을 뺀 수를 1로 만들고 1만 더해주면 된다.
- N // 2번째 수를 1로 만드는 데에 필요한 연산의 수 + 1 : N을 2로 나눈 수를 1로 만들고 2를 곱하면 된다.
- N // 3번째 수를 1로 만드는 데에 필요한 연산의 수 + 1 : N을 3으로 나눈 수를 1로 만들고 3을 곱하면 된다. 



 N에 따라 2로 나눌 수 없거나 3으로 나눌 수 없는 경우는 두 번째나 세 번째 경우를 제외해 주면 된다. 셋 중 가능한 모든 경우를 고려했을 때 연산 수의 최솟값이 N을 1로 만드는 연산의 최솟값이 된다.



> [*시행착오*](https://github.com/sirzzang/Python-Coding-Practice/blob/master/BOJ/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/BOJ1463_1%EB%A1%9C%EB%A7%8C%EB%93%A4%EA%B8%B0.py)
>
> 1. 처음에 DP로 접근을 못하고, 주어진 연산을 이용해 정말로 1로 만드려고 했다.
>    - 2로 나누고 3으로 나누고, 곧이 곧대로 접근했다.
>    - 바로 2나 3으로 나누는 것보다 1을 빼고 다른 연산을 적용할 때 최솟값이 되는 경우가 있다.
> 2. DP로 접근했을 때도 그 안에서 자꾸 경우를 나누려고 했다. 그럴 필요가 없다. 논리만 맞으면, 그리고 가능한 경우만 빼놓지 않고 체크했다면 그 다음 단계는 당연히 맞다.
> 3. 초기값 설정할 때 제대로 안 해주면 런타임에러가 발생하므로 주의한다.

![boj-1463-plz]({{site.url}}/assets/images/boj1463.png){: width="60%" height="60%"}{:.aligncenter}

<center><sup>화려하다 증말...</sup></center>



## 풀이 코드

> 37192KB, 548ms

```python
N = int(input())
dp = [0]*1000001

dp[1], dp[2], dp[3] = 0, 1, 1 # 초기값

for i in range(4, N+1):
    if i % 6 == 0:
        dp[i] = min(dp[i-1], dp[i//2], dp[i//3]) + 1
    elif i % 2 == 0:
        dp[i] = min(dp[i-1], dp[i//2]) + 1
    elif i % 3 == 0:
        dp[i] = min(dp[i-1], dp[i//3]) + 1
    else:
        dp[i] = dp[i-1]+1

print(dp[N])
```





---



# 3. 다른 풀이



[풀이 출처](https://www.acmicpc.net/source/13694219)

> 29056KB, 56ms.

```python
save = {1:0, 2:1}
def frog(n):
    if n in save:
        return save[n]
    m = 1+min(frog(n//2)+n%2, frog(n//3)+n%3)
    save[n] = m
    return m

n = int(input())
print(frog(n))
```



 주어진 수를 2와 3으로 나눈 몫과 나머지를 이용해서 로직을 구현했다. 나는 나누어 떨어지지 않으면 그 경우는 제외했는데, 애초에 이 풀이에서처럼 몫에 해당하는 부분에 해당하는 연산을 만들어 주고, 나머지만큼을 더해주면 된다!

 DP 구현 측면에서는 재귀함수와 메모이제이션 방법을 활용했다. 나는 재귀호출로 풀어보려고 했는데 못 했다.

- 메모이제이션을 어떻게 해야할 지 모르겠다.
- 재귀 호출 계속 하면 오히려 시간이 길어지지 않을까 생각했다.

 첫 번째는 내가 못한 거고, 두 번째는 내가 오해한 부분이라고 생각한다. 시간 엄청 짧다.

 

---

# 4. 배운 점, 더 생각해 볼 점



* 아직도 DP 사고가 익숙하지 않아서, 이전 단계를 생각하지 않고 곧이 곧대로 문제를 풀려고 한다. 하루 종일 계속 틀리고, 모든 경우를 나눠서 풀어내려고 하다 결국 깨달았다. 1을 만들기까지 찾아가는 경로가 최적이라고 증명할 수 없다면 절대 문제를 그렇게 풀면 안 된다. 그래서 DP를 쓰는거다.
* 배열 말고 ''재귀 + 메모이제이션''으로 DP 구현하는 방법을 아직 잘 모르겠다.

