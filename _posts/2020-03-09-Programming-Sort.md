---
title:  "[알고리즘] 정렬 알고리즘(Sort Algorithm)"
excerpt:
header:
  teaser: /assets/images/blog-Programming.jpg

categories:

  - Programming
    toc : true
    tags:
  - Python
  - Programming
  - 알고리즘
  - 정렬
  - 버블정렬
  - 카운팅정렬
  - 선택정렬
  - 삽입정렬
  - 퀵정렬
  - 삽입정렬
  - 병합정렬
---





---

**정렬, 왜 알아야 하는가?**

*부제 :이제서야 느끼는 정렬 공부의 필요성*



 지금보다도 더 코린이이던 몇 달 전, 백준에서 처음 마주한 "알고리즘"이라는 단어는 정렬 단계의 문제를 풀면서였다. 그 이전 수학2 단계까지는 논리로 어떻게든 풀 수 있었는데, 이 단계의 문제에서부터 점차 시간복잡도, 알고리즘이라는 단어가 등장하면서 ==멘붕==에 빠졌들었다.

 다행인지 불행인지, 이후 스터디를 시작하면서 스택, 큐 등 자료구조를 배우기 시작했고, 한 동안 정체 되어 있던 문제풀이를 다시 시작할 수 있게 되었다. 그리고 알게 모르게 몇 달 전만 해도 멘붕+포기에 빠지게 했던 단어들이 조금씩 보이기 시작했다. 

 그리고 문제를 풀면 풀수록, 정렬이 굉장히 중요하다는 것을 알게 되었다. 삽입과 삭제가 빈번하게 이루어지는 데이터에서 정렬이 되어 있는 경우와 되어 있지 않은 경우는 수행 속도에 굉장한 차이가 있다. 그리고 코딩테스트, 프로그래밍에서 아주 중요하고 강력하게 다뤄지는 **이진 탐색**을 적용할 때 정렬이 필요하다. ~~사실 예전에는 그냥 sorted() 사용하면 되는 거 아닌가라고 생각했는데, 이게 얼마나 바보 같은 생각이었는지 지금 와서야 깨닫는다.~~

 나중에 필요하면 공부해야지, 라고 미뤄뒀던 게 두 달 전이다. 늦은 건지 빠른 건지 모르겠지만, 일단 공부를 시작한다. 정렬은 컴퓨터공학을 전공한 사람들도 계속해서 공부하지 않으면 까먹는 분야라고 하니, 한 번에 다 이해하겠다는 욕심은 부리지 않겠다. 대신, 문제를 풀고 공부를 계속하면서 내용을 추가하고 보충하겠다.

---







# 파이썬으로 구현하는 알고리즘_정렬 알고리즘





**정렬**



 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순)이나 혹은 그 반대로(내림차순) 재배열하는 작업을 의미한다. 

 대표적인 정렬 알고리즘으로 버블정렬, 카운팅정렬, 선택정렬, 퀵정렬, 삽입정렬, 병합정렬 등이 있다. 각각의 정렬을 비교하면 다음과 같다(출처 : SW Expert Academy Learn [5차시](https://swexpertacademy.com/main/learn/course/lectureVideoPlayer.do)). 

| 알고리즘 |   평균   |   최악   | 알고리즘 기법 | 특징                                              | 안정/불안정 |
| :------: | :------: | :------: | :-----------: | :------------------------------------------------ | ----------- |
|   버블   |  O(n^2)  |  O(n^2)  |  비교, 교환   | 코딩이 가장 쉬움.                                 | 안정        |
|   선택   |  O(n^2)  |  O(n^2)  |  비교, 교환   | 교환의 횟수가 버블, 삽입보다 적음.                | 불안정      |
|    퀵    | O(nlogn) |  O(n^2)  |   분할 정복   | 최악의 경우 O(n^2)이지만, 평균적으로는 가장 빠름. | 불안정      |
|   삽입   |  O(n^2)  |  O(n^2)  |  비교, 교환   | n의 개수가 적을 때 효과적.                        | 안정        |
|   병합   | O(nlogn) | O(nlogn) |   분할 정복   | 연결 리스트의 경우 가장 효율적.                   | 안정        |
|  카운팅  |  O(n+k)  |  O(n+k)  |    비교환     | n이 비교적 작을 때만 가능.                        | 안정        |



 일단 위에 등장하지 않은 정렬에 대해서는 [여기](https://ratsgo.github.io/data%20structure&algorithm/2017/10/19/sort/)를 참고하며 공부하자.



* 안정 vs 불안정



 정렬 알고리즘에 있어서 빈번하게 등장하는 용어로 안정 정렬, 불안정 정렬이 있다. 정렬 후에 기존의 순서가 보장되는지에 따라 구분된다. 비교 시점에서는 같은 것으로 처리되지만, 실제 값이 다른 경우를 봐야 한다. 쉽게 말하면 **중복 값**이 있을 때, 그 중복된 값의 순서가 바뀌지 않으면 안정 정렬, 바뀌면 불안정 정렬이라고 한다.

| 초기 값           | 안정 정렬         | 불안정 정렬       |
| ----------------- | ----------------- | ----------------- |
| 2 5 1 *3* 4 **3** | 1 2 *3* **3** 4 5 | 1 2 **3** *3* 4 5 |

![stablenotstable]({{site.url}}/assets/images/stablenotstable.png)



* in-place 정렬



 입력 리스트 내부에서 정렬이 이루어지는 알고리즘이다. 정렬 도중 별도 저장 공간을 필요로 하지 않는다.





## 버블 정렬



 인접한 두 원소를 비교하며 자리를 계속 교환하는 정렬 방식이다. 모든 원소에 대해 **인접한 두 값을 비교**해서, **앞의 값이 뒤의 값보다 크면(혹은 작으면) 자리를 교환**한다. 한 단계가 끝나면 가장 큰(혹은 작은) 원소가 제일 마지막 자리에 정렬된다.

![버블정렬]({{site.url}}/assets/images/Bubble-sort.gif)

<center><sup>이미지 출처 : https://www.fun-coding.org/Chapter12-bubblesorting.html</sup></center>



*예) 55 7 78 12 42를 오름차순으로 버블정렬하는 과정*

**정렬 원소** 미정렬원소

|      리스트       | 비교 대상 | 동작 |     정렬 결과     |
| :---------------: | :-------: | :--: | :---------------: |
|   55 7 78 12 42   |   55 7    | 교환 |   7 55 78 12 42   |
|                   |   55 78   | 유지 |   7 55 78 12 42   |
|                   |   78 12   | 교환 |   7 55 12 78 42   |
|                   |   78 42   | 교환 | 7 55 12 42 **78** |
| 7 55 12 42 **78** |   7 55    | 유지 | 7 55 12 42 **78** |
|                   |   55 12   | 교환 | 7 12 55 42 **78** |
|                   |   55 42   | 교환 | 7 12 42 **55 78** |
| 7 12 42 **55 78** |   7 12    | 유지 | 7 12 42 **55 78** |
|                   |   12 42   | 유지 | 7 12 **42 55 78** |
| 7 12 **42 55 78** |   7 12    | 유지 | 7 **12 42 55 78** |
| 7 **12 42 55 78** |     7     | 종료 | **7 12 42 55 78** |



**코드 구현**

* 바깥쪽 반복문에 의해 안쪽 반복문의 범위가 제어된다.
* 한 단계를 마치면 마지막에 정렬이 종료된 원소가 위차하므로, 단계를 거칠수록 정렬의 범위가 1씩 작아진다.

```python
def BubbleSort(a):
    for i in range(len(a)-1, 0, -1): 
        # reversed(range(len(a)))와 동일한 의미. 
        for j in range(0, i):
            if a[j] > a[j+1]: # swap
                a[j], a[j+1] = a[j+1], a[j]
     return a
```

* 반복문 범위 설정에 따라 다음과 같이 구현할 수도 있다. 위의 방식보다 이해가 조금 더 직관적이다.

```python
def BubbleSort(a):
    for i in range(len(a)): # 리스트의 크기만큼 아래 횟수 반복.
        for j in range(len(a)-1): # 각 단계별로 정렬이 끝나지 않은 원소들.
            if a[j] > a[j+1]:
                a[j+1], a[j] = a[j], a[j+1]
    return a
```



**시간 복잡도**

 리스트 안에 n개의 원소가 존재할 때, 최악의 경우 (n-1) + (n-2) + ... + 1번 비교가 이루어지므로, 최악의 시간 복잡도는 O(n^2)이다.





## 선택 정렬



 사람의 사고방식으로 떠올릴 수 있는 가장 일반적인 정렬 알고리즘이다. 학교 다닐 때 키순서대로 줄을 섰던 것을 떠올리면 된다. 가장 작은(혹은 가장 큰) 수부터 정렬하기 시작하여 위치를 교환하는 정렬 알고리즘이다.

 선택 정렬은 주어진 자료 중 가장 작은(혹은 가장 큰) 값의 원소부터 차례대로 선택하여 위치를 교환해 나간다. 이를 적용하기 위해 먼저 셀렉션 알고리즘에 대해 알아보자.





### 셀렉션 알고리즘



 셀렉션 알고리즘은 자료에서 k번째로 큰(혹은 작은) 원소를 찾는 알고리즘으로, 최솟값, 최댓값 혹은 중간값을 찾을 때 주로 적용한다.



**코드 구현**

* 1번째부터 k번째 순번까지 작은 원소들을 찾아 list의 앞쪽으로 이동시킨다.
* list의 k번째 원소를 반환한다.

```python
def SelectAlgorithm(list, k):
    for i in range(k): # k번째 순번까지
        min_idx = i
        for j in range(i+1, len(list)): # 뒤의 원소가 앞의 원소보다 크다면 
            if list[min_idx] > list[j]: # 최소 idx 교체.
                min_idx = j 
        list[i], list[min_idx] = list[min_idx], list[i] # i번째와 자리 바꿈.
    return list[k-1] # k번째로 작은 수 반환
```



 위와 같은 셀렉션 알고리즘을 전체 자료에 k = 1로 생각하고 적용하면, 그것이 바로 선택 정렬이다. 



![selection sort]({{site.url}}/assets/images/Selection-Sort.gif)

<center><sup>이미지 출처 : https://www.fun-coding.org/Chapter12-selectionsorting.html</sup></center>



 정렬을 수행하는 방법은 다음과 같다.

1. 주어진 리스트에서 최솟값(혹은 최댓값)을 찾는다.
2. 그 값을 리스트의 맨 앞 값과 교환한다. 리스트에서 맨 앞 원소는 정렬이 완료된다.
3. 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.



*예) 64 25 10 22 11을 오름차순으로 선택정렬하는 과정*

**정렬 원소** 미정렬원소

|       리스트       | 최솟값 | 맨 앞 |     정렬 결과      |
| :----------------: | :----: | :---: | :----------------: |
|   64 25 10 22 11   |   10   |  64   | **10** 25 64 22 11 |
| **10** 25 64 22 11 |   11   |  25   | **10 11** 64 22 25 |
| **10 11** 64 22 25 |   22   |  64   | **10 11 22** 64 25 |
| **10 11 22** 64 25 |   25   |  64   | **10 11 22 25 64** |



**시간 복잡도**

 총 **O(N^2)**의 시간 복잡도를 가진다. 

 앞에서부터 한 칸씩 진행하고, 한 칸씩 진행할 때마다 전체 칸을 돌아야 하기 때문이다. 즉,  반복문을 통해 모든 인덱스의 값에 접근해야 하기 때문에 기본적으로 O(N)의 시간복잡도를 갖는다. 또한 하나의 루프 안에서 현재 인덱스의 값과 다른 인덱스의 값을 비교하여 최솟값을 찾아야 하므로, 인덱스 위치에 따라 또 O(N)의 시간을 필요로 한다.



**코드 구현**

* 뒷 순번의 인덱스로 갈수록 비교할 범위가 줄어든다.
* 안쪽 반복문에서는 현재 인덱스부터 마지막 인덱스까지 최솟값의 인덱스를 찾아내고, 바깥쪽 반복문에서 최솟값의 인덱스와 현재 인덱스에 있는 값을 교환한다.

```python
def SelectionSort(a):
    for i in range(0, len(a)-1):
        min_idx = i
        # 최솟값 인덱스 찾기
        for j in range(i+1, len(a)):
            if a[min_idx] > a[j]:
                min_idx = j
        # 최솟값 인덱스의 값과 위치 바꾸기
        a[i], a[min_idx] = a[min_idx], a[i]
    return a
```





## 퀵 정렬



 분할 정복 방식을 적용해 정렬을 진행하는 알고리즘이다.

 리스트 중 하나를 피봇으로 선택하고, 피봇보다 *작은* 원소는 **왼쪽**에, *큰* 원소는 **오른쪽**에 정렬한다. 이후 피봇값을 중심으로 리스트를 **분할**하고, 분할된 각각의 리스트에 재귀적으로 이 과정을 반복한다.

 이렇게 작은 쪽의 배열, 큰 쪽의 배열 각각에 대해 정렬 과정을 반복하다 보면 각각의 파티션에 정렬된 파티션이 두 개밖에 남지 않게 된다. 이는 정렬이 완료되었음을 의미하며, 각각의 리스트를 작은 리스트로 분할하여 모든 정렬을 완료함으로써 정렬 문제를 **정복**하게 된다.



![quick sort]({{site.url}}/assets/images/quick-sort.png)

<center><sup>이미지 출처 : https://www.fun-coding.org/Chapter12-selectionsorting.html</sup></center>

![quick sort 2]({{site.url}}/assets/images/quick2.png)

<center><sup>이미지 출처 : https://koreanfoodie.me/107</sup></center>

한 단계가 완료될 때마다 피봇의 위치가 확정된다.





**정렬 원소** {미정렬 원소}

| 정렬 대상 리스트      | 피봇 | L    | R    | 정렬 결과                                                    |
| --------------------- | ---- | ---- | ---- | ------------------------------------------------------------ |
| 68 11 29 3 15 9 32 23 | 3    | 68   | 68   | **3** {11 29 68 15 9 32 23}<br />1. L = R = 68이므로 68과 피봇 교환.<br />2. 피봇 3의 위치 확정.<br />3. 피봇 3의 왼쪽은 공집합이므로 ,오른쪽에 대해서만 이후 정렬 수행. |
| 11 29 68 15 9 32 23   | 15   | 29   | 9    | **3** {11 9 68 15 29 32 23}<br />1. L과 R이 만나지 않았으므로 위의 작업 반복. |
|                       | 15   | 68   | 68   | **3** {11 9} **15** {68 29 32 23} <br />1. L = R = 68이므로 68과 피봇 교환.<br />2. 피봇 15의 위치 확정.<br />3. 피봇 왼쪽과 오른쪽에 대해 정렬 수행 |
| 11 9                  | 11   |      |      | **3** {9} **11 15** {68 29 32 23}<br />1. L의 원소가 그 자체로 피봇이므로, 그 자체로 교환이 일어난 것으로 간주.<br />2. 피봇 11의 위치 확정.<br /> |
| 9                     | 9    |      |      | **3 9 11 15** {68 29 32 23}<br />1. 피봇 9의 위치 확정.      |
| 68 29 32 23           | 29   | 68   | 23   | **3 9 11 15** {23 29 32 68}<br />1. L과 R이 만나지 않았으므로 위의 작업 반복 |
|                       | 29   | 29   | 29   | **3 9 11 15** {23} **29** {32 68}<br /> 1. R의 원소가 그 자체로 피봇이므로 자리 교환 발생.<br />2. 피봇 29의 위치 확정. |
| 23                    | 23   |      |      | **3 9 11 15 23 29** {32 68}<br />1. 피봇 23의 위치 확정.     |
| 32 68                 | 32   | 32   | 32   | **3 9 11 15 23 29 32** {68}<br />1. L = R = 32이므로 피봇 32의 위치 확정. |
| 68                    | 68   |      |      | **3 9 11 15 23 29 32 68**<br />1. 피봇 68의 위치 확정.       |



**시간 복잡도**

 평균적으로**O(NlogN)**의 시간 복잡도를 가진다. 

 파티션 안 원소의 개수가 1이 될 때까지 분할하기 때문에, 파티션으로 분할하는 횟수는  N번이다. 따라서 O(N)의 시간을 필요로 한다. 그러나, 한 번 분할할 때마다 탐색해야 할 데이터가 절반씩 줄어들기 때문에 한 번 돌 때 탐색을 위해서는 O(logN)의 시간을 필요로 한다.

 그러나 최악의 경우 **O(N^2)**의 시간 복잡도를 가진다.

 이는 피봇의 왼쪽 요소가 매 번 하나가 되도록 피봇이 선택되는 경우에 발생한다. 이 경우, 우선 N번의 데이터 분할을 진행하여 O(N)의 시간이 필요하다. 이후, N개의 요소에 대해 모두 정렬을 수행해야 하기 때문에 추가적으로 O(N)의 시간이 필요하게 되는 것이다. 피봇을 어떻게 선택하느냐에 따라 탐색 및 분할에 소요되는 시간이 결정되기 때문에 피봇의 선택이 매우 중요한 정렬 알고리즘이다.

|                    최선의 경우 : O(nlogn)                    |                     최악의 경우 : O(n^2)                     |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![best]({{site.url}}/assets/images/sort-time-complexity-etc1.png) | ![worst]({{site.url}}/assets/images/sort-time-complexity-etc2.png) |

<center><sup>퀵 정렬 시간 복잡도(출처 : https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html)</sup></center>

 *그럼에도 불구하고, 퀵 정렬은 평균 시간 복잡도가 매우 우수하기 때문에 가장 자주 사용된다.*

 따라서 피봇 값을 선택할 때 시간 복잡도를 낮출 수 있는 방식을 사용하는 것이 좋다. ㅇ컨대, 1) 정해진 위치가 아니라 랜덤하게 피봇값을 선택하거나, 2) 몇 개의 값을 샘플링해 중앙값에 가까운 피봇을 선택하거나, 3) 배열의 첫 값과 중앙값, 그리고 마지막 값 중 크기가 중간인 값을 사용할 수 있다.



 

**코드 구현**

 배열의 **중앙에 있는 값**을 피봇으로 선택해 구현하는 방식을 선택한다.

* in-place 방식 : 정렬과 파티션, 2개의 내부 함수로 나눈다.
  * 정렬 함수는 재귀 함수로, 정렬 범위의 시작 인덱스와 끝 인덱스를 인자로 받는다.
  * 파티션 함수는 정렬할 범위를 인자로 받아 피봇의 값을 구한다. 이 함수 내에서는 피봇의 좌우측 값들을 정렬하고, 분할 기준점의 인덱스를 피봇으로서 반환한다.
    * 왼쪽 인덱스(L)를 계속해서 증가시키고, 오른쪽 인덱스(R)를 계속해서 감소시키기 위한 while문을 작성한다. while문은 두 인덱스가 서로 만날 때까지 반복된다.
      * 왼쪽(L)에서 오른쪽(R)으로 이동하며 피봇과 비교해 피봇보다 큰 값의 인덱스를 찾는다.(*피봇보다 큰데 좌측에 있는 값을 찾는다.*)
      * 오른쪽(R)에서 왼쪽(L)으로 이동하며 피봇과 비교해 피봇보다 작거나 같은 값을 찾는다.(*피봇보다 작은데 우측에 있는 값을 찾는다.*)
      * 두 인덱스가 서로 만나지 않는다면, 왼쪽(L) 인덱스의 값과 오른쪽 인덱스(R)의 값의 위치를 바꾼다.
    * 두 인덱스가 만나 while문을 빠져나오면, 다음 재귀 호출의 기준점이 될 시작 인덱스(L)를 반환한다.

```python
def QuickSort(a, begin, end):
    if begin < end :
        p = Partition(a, begin, end) # 분할 기준 인덱스
        QuickSort(a, begin, p-1) # 왼쪽 배열에 대해 재귀 호출
        QuickSort(a, p+1, end) # 오른쪽 배열에 대해 재귀 호출
    return a
        
def Partition(a, begin, end):
    pivot_idx = (begin + end) // 2 # 피봇 인덱스 : 중간 위치로 설정.
    print(a[pivot_idx]) # 피봇 값 확인 위해
    L = begin
    R = end
    while L < R: # L이랑 R 만날 때까지 아래 과정 반복
        while (a[L] < a[pivot_idx] and L < R) : # 피봇 값보다 왼쪽에 있는데 작다면 L 증가 = 피봇값보다 크거나 같은데 왼쪽에 있는 원소 찾기.
            L += 1
        while (a[R] >= a[pivot_idx] and L < R) : # 피봇 값보다 오른 쪽에 있는데 크다면 R 증가 = 피봇값보다 작은데 오른쪽에 있는 원소 찾기.
            R -= 1
        if L < R : # 위의 과정을 거쳤는데 만나지 않은 경우
            if L == pivot_idx : # L이 피봇 값이면
                pivot_idx = R # 피봇을 오른쪽으로 바꾸기
            a[L], a[R] = a[R], a[L] # 만나지 않았다면, L과 R 위치의 원소 바꾸기
    a[pivot_idx], a[R] = a[R], a[pivot_idx]
    return R
```



 위와 같은 내용을 아래와 같이 구현할 수도 있다.



<details>
    <summary>접기/펼치기</summary>
    <div markdown="1">

```python

    def QuickSort(a, begin, end):
    if begin < end :
        p = Partition(a, begin, end)
        QuickSort(a, begin, p-1)
        QuickSort(a, p+1, end) # 인덱스 체크하기
    return a
        
def Partition(a, begin, end):
    pivot_idx = (begin + end) // 2 # 피봇 인덱스
    L = begin
    R = end
    while L < R:
        while (a[L] < a[pivot_idx] and L < R) :
            L += 1
        while (a[R] >= a[pivot_idx] and L < R) :
            R -= 1
        if L < R :
            if L == pivot_idx :
                pivot_idx = R
            a[L], a[R] = a[R], a[L]
    a[pivot_idx], a[R] = a[R], a[pivot_idx]
    return R 
```


​       
​    
    </div>

</details>



* 조금 더 간결하고 이해하기 쉬운 구현을 적용하면 다음과 같다. 그러나, 이 방식은 매 번 재귀 호출을 진행할 때마다 새로운 리스트를 생성하기 때문에, 메모리 사용 측면에서 매우 비효율적이다. 따라서 원리만 이해하고 넘어가도록 한다.
  * 피봇보다 작은 값, 동일한 값, 큰 값을 저장할 3개의 리스트를 생성한다.
  * 반복문을 통해 각 값과 피봇 값을 비교한 후, 해당하는 리스트에 추가한다.
  * 작은 값과 큰 값을 담고 있는 왼쪽과 오른쪽의 배열을 대상으로, 퀵 정렬 함수를 재귀적으로 호출한다.
  * 재귀 호출의 결과를 크기 순으로 합쳐 정렬된 리스트를 얻는다.

```python
def QuickSort(a):
    if len(a) <= 1:
        return a
    # 피봇 선택
    pivot = arr[len(arr)//2]
    lesser_a, equal_a, greater_a = [], [], []
    for num in a:
        if num < pivot:
            lesser_a.append(num)
        elif num > pivot:
            greater_a.append(num)
        else:
            equal_a.append(num)
    return QuickSort(lesser_a) + equal_a + QuickSort(greater_a)
```











## 카운팅 정렬(a.k.a 계수 정렬)



 원소를 직접 비교하지 않고, 원소들의 개수를 세어 정렬하는 방식이다. 즉, 항목의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 센다.

 

 정렬을 수행하는 방법은 다음과 같다.

1. 항목의 개수를 저장할 COUNTS 배열을 만든다. 
   * 이 때 COUNTS를 세기 위한 충분한 공간을 할당하려면, 주어진  집합에서 가장 큰 정수를 알아야 한다.
   * 또한 COUNTS는 정수 항목들로 직접 인덱스되는 배열이어야 한다.
2. 주어진 자료 집합(DATA)에서 각 항목 i가 총 몇 개 있는지 세고, COUNTS의 i번째 칸에 저장한다.
3. COUNTS에서 앞에서 뒤로 가며, i번째 칸의 숫자를 i+1번째 칸에 누적한다. 이 조정 작업이 완료되면, COUNTS 배열의 값은 정렬 후 반환할 배열 TEMP에서 인덱스가 나타내는 i라는 항목이 TEMP 배열의 몇 번째 칸에 들어가야 하는지 보여준다.
4. 주어진 집합 DATA의 마지막 항목부터 정렬한다.
   * 정렬해야 할 각 항목의 값을 i라고 한다.
   * COUNTS의 i번째 칸에 있는 수를 room_number한다.
   * TEMP의 room_number칸에 i를 삽입한다.
   * COUNTS의 i번째 칸에 있는 수를 1 감소시킨다.



![카운팅정렬]({{site.url}}/assets/images/counting-sort.png)

<center><sup>이미지 출처 : https://m.blog.naver.com/PostView.nhn?blogId=dnpc7848&logNo=221439395086&categoryNo=15&proxyReferer=https%3A%2F%2Fwww.google.com%2F</sup></center>



*예) 0 4 1 3 1 2 4 1를 오름차순으로 카운팅정렬하는 과정*

- DATA : [0 4 1 3 1 2 4 1]

- COUNTS : [1 4 5 6 8]

  - 조정 전 COUNTS : [1 3 1 1 2]
  - 조정 전 COUNTS의 인덱스는 DATA의 항목을 나타내며, 값은 각 항목이 등장한 횟수를 의미한다.

  

<sub>파이썬의 리스트 인덱스가 0부터 시작해서 헷갈릴 수 있다. 여기서 COUNTS[i]는 TEMP의 몇 번째 칸인지를 의미한다고 생각하자</sub>

| i(정렬할 항목) | COUNTS[i] |      TEMP       | 정렬 후 COUNTS |
| :------------: | :-------: | :-------------: | :------------: |
|       1        |     4     | _ _ _ 1 _ _ _ _ |   1 3 5 6 8    |
|       4        |     8     | _ _ _ 1 _ _ _ 4 |   1 3 5 6 7    |
|       2        |     5     |  _ _ _ 1 2 _ 4  |   1 3 4 6 7    |
|       1        |     3     | _ _ 1 1 2 _ _ 4 |   1 2 4 6 7    |
|       3        |     6     | _ _ 1 1 2 3 _ 4 |   1 2 4 5 7    |
|       1        |     2     | _ 1 1 1 2 3 _ 4 |   1 1 4 5 7    |
|       4        |     7     | _ 1 1 1 2 3 4 4 |   1 1 4 5 6    |
|       0        |     1     | 0 1 1 1 2 3 4 4 |   0 1 4 5 6    |





**코드 구현**

* 바깥쪽 반복문에 의해 안쪽 반복문의 범위가 제어된다.
* 한 단계를 마치면 마지막에 정렬이 종료된 원소가 위차하므로, 단계를 거칠수록 정렬의 범위가 1씩 작아진다.

```python
def CountingSort(A, k):
    # A : 입력 리스트. 
    # k: A의 항목 중 최댓값.
    # TEMP : 정렬될 결과 리스트.
    # COUNTS: 카운트 리스트.
    
    COUNTS = [0]*(k+1)
    TEMP = [0]*len(A)
    
    # 개수 세서 COUNTS에 저장
    for a in A:
        COUNTS[a] += 1
    # 인덱스로 구현한다면 for i in A: C[A[i]] += 1와 동일
        
    # COUNTS 조정.
    for i in range(1, len(COUNTS):
       COUNTS[i] += COUNTS[i-1]
    # for i in range(len(COUNTS)) : COUNTS[i+1] == COUNTS[i]와 동일
    
    for i in range(len(TEMP)-1, -1, -1):
        # reversed(range(len(TEMP)))와 동일
        TEMP[COUNTS[A[i]]-1] = A[i]
        COUNTS[A[i]] -= 1
    
    return TEMP
```



**시간 복잡도**

 시간 복잡도는 O(n+k)로, n은 배열할 항목의 수, k는 항목 중 최댓값을 의미한다. 

 만약 항목 중 최댓값이 n보다 작으면 시간 복잡도는 O(n)에 가까워지지만, 극단적인 예로 k가 매우 큰 수이면 O(무한)이 될 수도 있다. 따라서 정렬할 수의 최댓값에 영향을 받는 알고리즘이라고 볼 수 있다.



**특징**

  이전까지의 알고리즘과 달리 처음으로 단 한 번의 비교도 수행하지 않고 정렬을 진행하는 알고리즘이다. 그러나 숫자를 세서 저장할 공간이 필요하므로, 메모리 낭비가 야기될 수 있다. 예컨대, 만약 배열이 0, 1, 2, 3, 10억이라면, COUNTS로 (10억+1)칸을 만들어야 한다.



**활용**

* 정수나, 정수로 표현될 수 있는 자료에 대해서 적용한다. 위의 구현 과정을 통해 살펴보았듯, 정수 항목으로 인덱스되는 발생 횟수들의 리스트를 사용하기 때문이다. 
* 원소들의 개수를 세어 정렬하기 때문에, 중복값이 많이 분포되어 있는 배열을 정렬할 때 효과적으로 작용한다.
* 또한, 시간복잡도를 지배하는 것이 배열의 최댓값이기 때문에 정렬할 항목들이 특정한 범위 안에 존재하는 경우 사용한다.

 카운팅 정렬을 사용하는 대표적인 예는, 26개의 알파벳으로 이루어진 문자열에서 Suffix Array를 얻는 경우다.



















최악의 시간 복잡도는 O(n^2)으로 합병 정렬에 비해 효율이 좋지 못함.

그러나 퀵 정렬인 이유는, 평균 복잡도가 nlogn이기 때문.























|        | 합병 정렬                             | 퀵 정렬                                                      |
| ------ | ------------------------------------- | ------------------------------------------------------------ |
| 공통점 | 두 개로 분할해 각각 정렬              | 두 개로 분할해 각각 정렬                                     |
| 차이점 | 분할 시 단순히 두 부분으로 나눔.      | 분할 시, 기준 아이템을 중심으로 작은 것은 왼편, 큰 것은 오른 편에 위치. |
|        | 각 부분 정렬 후 합병 후처리작업 필요. | 정렬 후 후처리 작업 필요 업슴.                               |

