---
title:  "[자료구조] 우선순위 큐(힙)"
excerpt:
header:
  teaser: /assets/images/blog-Programming.jpg
categories:
  - Python
toc : true
tags:
  - Python
  - 자료구조
  - 우선순위 큐
  - 힙
---







# 파이썬으로 구현하는 자료구조_우선순위 큐

---

---



**우선순위 큐? 힙? 같은 거야?!?!!**



 **큐**는 **FIFO**, 즉, 먼저 들어간 데이터가 항상 먼저 나오는 *선입선출* 형태의 자료구조이다. **우선순위 큐**는 들어간 순서가 아닌, **우선순위가 높은** 데이터가 먼저 나오는 자료구조이다. 예컨대, 숫자가 클수록 우선순위를 높게 부여하거나(최대 힙), 숫자가 작을수록 우선순위를 높게 부여하는(최소 힙) 것이다.

>  일단은, 일반적인 큐가 들어간 순서에 우선순위를 줬다고 본다면, 우선순위 큐는 들어간 순서가 아니라 사용자가 지정한 순서에 따라 순위를 부여한다고 이해하자. 



 그런데, 우선순위 큐를 이름만 본다면 큐의 확장판 같다. 그래서 자료구조를 잘 모르는 상태에서 우선순위 큐를 구현하기 위해 '큐를 구현한 방법을 조금만 확장하면 되겠지'라고 생각한다면, 어려움을 겪을 수도 있다. 우선순위를 기반으로 `enqueue`와 `dequeue`를 진행해야 하기 때문에, 데이터에 어떻게 우선순위를 부여할 것인지 머리를 한참 싸매고 고민해야 할지도 모른다. ~~내가 그랬기 때문이다.~~



 우선순위 큐를 구현하는 방법으로는 여러 가지가 있다. ==첫째==, *Array*(파이썬에서는 내장 List)을 이용하거나, ==둘째==, *LinkedList*를 이용하거나, ==셋째==, *힙*을 이용한다.



 그런데 우선순위에 따른 삽입 및 삭제 연산을 구현하기 위해 배열이나 연결 리스트를 사용한다면, 그 위치를 찾기 위해서 *처음부터 마지막까지* 데이터들의 우선순위를 비교해야 할 수도 있다. 

 이는 매우 비효율적이기 때문에, 우선순위 큐를 구현할 때는 주로 **힙**이라는 자료구조를 사용한다.



**"*즉, 우선순위 큐와 힙은 별개의 개념이고, 우선순위 큐를 구현할 때 힙이라는 자료구조를 사용하는 것이다.*"** 

아주 기본적인 것이지만, 우선순위 큐와 힙의 범위가 제대로 구분되지 않는다면 ~~나처럼~~ 한참을 고민하게 된다. 절대로 헷갈리지 말자.







## 힙



 우선순위 큐를 구현하기 위해서는 **힙(*heap*)**에 대해 알아야 한다. 힙의 정의란 다음과 같다.

---

**힙**이란, 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 *완전이진트리*를 기본으로 한 자료구조로, A가 B의 부모노드이면, A의 키 값과 B의 키 값 사이에 *대소 관계*가 성립한다는 특징을 가지고 있다.<sub>*_위키피디아*</sub>

---

 단순히 정의만 읽었을 뿐인데, 완전이진트리 개념이 등장한다. 힙이라는 자료 구조를 파고 들어가며 공부하는 게 목적 아니다. 따라서 일단 완전이진트리가 무엇인지, 힙이 기본적으로 무엇인지 살펴 보고 넘어가도록 한다.



### 완전이진트리

<sup>\- 출처 : [엔지니어대한민국](https://www.youtube.com/watch?v=LnxEBW29DOw)</sup>

 

 이진트리는 **자식 노드가 최대 2개까지 붙는 트리**이다. 

 그 중에서도 **완전이진트리**란, *""모든 노드가 계층별로 왼쪽부터 채워져 있는 트리"*를 의미한다. 마지막 트리를 제외한 모든 서브트리의 레벨이 같아야 하며, 마지막 레벨은 왼쪽부터 채워져 있다.

![완전이진트리]({{site.url}}/assets/images/perfectbinary.png)



**헷갈리지 말 것**

종종 완전이진트리를 검색하면, 포화이진트리가 나오는데, 둘은 엄연히 다른 개념이다. 

|           완전이진트리<br />(Complete Binary Tree)           |            포화 이진 트리<br />(Full Binary Tree)            |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![완전이진트리]({{site.url}}/assets/images/completebinary.png) | ![포화이진트리]({{site.url}}/assets/images/fullbinary.png}}) |

<sup>그림 출처 : https://ratsgo.github.io/data%20structure&algorithm/2017/10/21/tree/ </sup>

포화이진트리란 모든 레벨에서 노드들이 *꽉* *채워진* 이진트리로, 정이진트리라고도 한다. 반면 완전이진트리는 마지막 레벨에서는 노드들이 꽉 채워져 있지 않아도 된다.





### 힙이란?



 완전이진트리 중, 특정 규칙을 만족하도록 데이터 노드를 구성한 트리이다. 힙 트리에서 데이터의 처리는 다음과 같은 과정을 거쳐 이루어진다. [구현 과정](https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html)은 나중에 힙을 자세히 공부할 때 보도록 한다.

| 데이터 삽입                                         | 데이터 삭제                                         |
| --------------------------------------------------- | --------------------------------------------------- |
| ![삽입]({{site.url}}/assets/images/heap_insert.jpg) | ![삭제]({{site.url}}/assets/images/heap_delete.jpg) |

<sup>그림 출처 : https://namu.wiki/w/힙%20트리</sup>





### 힙의 종류



 힙 트리의 종류로는 최대 힙, 최소 힙의 두 가지가 있다. 위에서 말한 노드 구성 규칙에 따라 그 종류가 나뉘어지는 것이다.

![힙의 종류]({{site.url}}/assets/images/types-of-heap.png)



**최대 힙**

* 부모 노드의 값이 항상 자식 노드의 값보다 크거나 같아야 한다.

* `key`([부모](https://python.flowdas.com/library/heapq.html) 노드) >= `key`(자식 노드).

**최소 힙**

* 부모 노드의 키 값이 항상 자식 노드의 값보다 작거나 같아야 한다.
* `key`(부모 노드) <= `key`(자식 노드).



 따라서 루트 노드에는 항상 데이터의 최댓값 혹은 최솟값이 저장되어 있기 때문에, 루트 노드에 접근함으로써 최댓값 혹은 최솟값을 O(1)의 시간 복잡도 안에 찾을 수 있다.





**어떻게 구현할까?**



 물론 이전에 스택, 큐를 class로 구현했듯 힙을 class로 만들어 사용<sup>예를 들면, [이 블로그](https://smlee729.github.io/python/data%20structure/2015/04/10/2-priority-queue.html)나, [이 블로그](https://daimhada.tistory.com/108)처럼...</sup>할 수 있다. 그렇지만 일단 파이썬에서 제공하는 내장 모듈을 통해 힙을 구현한 뒤, 트리 등 다른 자료구조에 대해 학습이 완료되면 직접 구현해보도록 한다. ~~절대 내가 코린이라서 그런 게 아닌 걸로(...)~~

 



## 파이썬의 heapq 모듈



 파이썬에서 우선순위 큐 알고리즘을 구현할 수 있도록 제공하는 내장 모듈([공식 문서](https://python.flowdas.com/library/heapq.html))이다. 다만, 이 모듈은 **최소 힙**만을 지원한다. 따라서 최댓값을 찾아야 하는 경우는, 이 모듈을 응용하여 다른 방식으로 활용해야 한다.

 

 이 점에 유의하며 heap큐 모델의 사용 방법을 알아보자.



 파이썬이 설치되어 있다면, 다음과 같이 간단하게 임포트하여 힙 관련 함수를 사용할 수 있다.

```python
import heapq
```

 한편,  파이썬의 `heapq` 모듈은 일반 리스트를 최소 힙처럼 사용 다룰 수 있도록 한다. 따라서 아래와 같이 빈 리스트를 생성한 후, 모듈의 함수를 호출할 때 이 리스트를 인자로 넘기면 된다. 

```python
h = []
```

 즉, 빈 리스트를 생성하고, `heapq` 모듈의 함수를 통해 원소를 추가하거나 삭제하면, 그 결과로 반환되는 리스트가 바로 힙이 되는 것이다!





 사용할 수 있는 주요 함수는 다음과 같다.



### heappush

힙에 원소를 추가한다. 원소를 추가할 대상 리스트와 추가할 요소를 인자로 넣는다.

```python
h = []
heapq.heappush(h, 5)
heapq.heappush(h, 7)
heapq.heappush(h, 1)
heapq.heappush(h, 3)
print(h)

(실행 결과)
[1, 3, 5, 7]
```

 아래와 같이 튜플을 요소로 넣으면 튜플의 첫 번째 원소에 따라 정렬의 우선순위가 설정된다.

```python
h2 = []
heapq.heappush(h2, (5, 'write code'))
heapq.heappush(h2, (7, 'release product'))
heapq.heappush(h2, (1, 'write spec'))
heapq.heappush(h2, (3, 'create tests'))
print(h2)

(실행 결과)
[(1, 'write spec'), (3, 'create tests'), (5, 'write code'), (7, 'release product')]
```



### heappop

힙에서 가장 작은 원소를 삭제하고, 그 값을 리턴한다. 원소를 삭제할 대상 리스트만을 인자로 넣는다.

```python
print(heapq.heappop(h))
print(h)

(실행 결과)
1
[3, 7, 5]
```

```python
print(heapq.heappop(h2))
print(h2)

(실행 결과)
(1, 'write spec')
[(3, 'create tests'), (7, 'release product'), (5, 'write code')]
```



**[참고] 최솟값 삭제하지 않고 얻기**

 힙에서 최솟값을 삭제하지 않고 단순히 얻기만 하려면, 인덱스를 통해 접근하면 된다.

```python
print(h[0])

(실행 결과)
3
```

 주의할 점은, 힙 트리를 리스트로 표현한 것이기 때문에, 인덱스 0에 가장 작은 원소가 있다고 해서, 인덱스 1에 두 번째로 작은 원소, 인덱스 2에 세 번쨰로 작은 원소가 있다는 보장이 없다는 것이다. 따라서 두 번째로 작은 원소를 얻으려면 `heappop()`을 진행하고 난 후 인덱스 0에 접근해야 한다.



### heapify

이미 원소가 들어 있는 리스트를 힙으로 만든다. 리스트 내부의 원소들이 힙 트리 구조에 맞게 재배치되며 최솟값이 인덱스 0에 위치하게 된다.

```python
heap = [-1, 8, 15, 29, 3, -7, 3, -8, 5]
heapq.heapify(heap)
print(heap)

(실행 결과)
[-8, -1, -7, 5, 3, 15, 3, 29, 8]
```

인자로 넘기는 리스트 내 원소를 힙 구조에 맞게 정렬해야 하기 때문에 O(N)의 시간 복잡도를 갖는다.(문제 풀이 시 함부로 heapify를 하면 안 된다. [참고](https://www.acmicpc.net/board/view/40809))



### nlargest, nsmallest

리스트에서 n번째 큰 값을 반환하거나(nlargest), 작은 값(nsmallest)을 반환한다. 리스트 요소를 힙 트리 구조로 만든 후 반환하기 때문에, n이 1이라면 `min()`이나 `max()`를 사용하는 것이, n이 리스트의 길이와 비슷하거나 같다면 `sorted`를 사용한 후 slicing을 사용하는 것이 낫다.

```python
print(heapq.nlargest(3, heap))
print(heapq.nsmallest(3, heap))

(실행 결과)
[29, 15, 8]
[-8, -7, -1]
```



### 최대 힙의 구현



 위에서도 말했듯, `heapq` 모듈을 활용하여 최대 힙을 구현하려면 응용이 필요하다. 인터넷을 [찾아 보면](https://stackoverflow.com/questions/2501457/what-do-i-use-for-a-max-heap-implementation-in-python), `heapq._heapify_max`나 `heapq._heappop_max`를 사용할 수 있는 것 같다. 그렇지만 push할 수 없고, 이미 최소힙으로 정렬된 상태에서 최댓값을 찾는 것이기 때문에 온전히 최대 힙을 구현한 것이라는 생각이 들지는 않는다.



  튜플을 원소로 추가하여 힙을 만들 수 있다는 원리를 이용하면, 최대 힙을 구현할 수 있다([참고](https://stackoverflow.com/questions/48255849/how-to-get-the-max-heap-in-python)). 튜플 내 우선순위를 값에 `-`를 취한 값으로 설정하면 된다. 양수 범위에서 큰 값은 음수 범위에서는 작아지기 때문에, 가장 큰 값이 최솟값이 되는 것이다. 이후 최댓값을 불러오고 싶다면, `heappop`을 한 뒤, 튜플의 두 번째 요소만을 읽어 오면 된다.



```python
nums = [24, 11, -7, -3, 18, 55]
myheap = []
for num in nums:
  heapq.heappush(myheap, (-num, num))  # (우선 순위, 값)
print(myheap)
print(heapq.heappop(myheap)[1])

(실행 결과)
[(-55, 55), (-18, 18), (-24, 24), (3, -3), (-11, 11), (7, -7)]
55
```