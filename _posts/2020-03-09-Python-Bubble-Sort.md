---
title:  "[알고리즘] 정렬 알고리즘(Sort Algorithm)"
excerpt:
header:
  teaser: /assets/images/blog-Programming.jpg

categories:
  - Python
toc : true
tags:
  - Python
  - 알고리즘
  - 정렬
  - 버블정렬
---

---



# 파이썬으로 구현하는 알고리즘_버블 정렬



## 들어가기 전에





### 정렬



 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순)이나 혹은 그 반대로(내림차순) 재배열하는 작업을 의미한다. 

 대표적인 정렬 알고리즘으로 버블정렬, 카운팅정렬, 선택정렬, 퀵정렬, 삽입정렬, 병합정렬 등이 있다. 각각의 정렬을 비교하면 다음과 같다(출처 : SW Expert Academy Learn [5차시](https://swexpertacademy.com/main/learn/course/lectureVideoPlayer.do)). 

| 알고리즘 |   평균   |   최악   | 알고리즘 기법 | 특징                                              | 안정/불안정 |
| :------: | :------: | :------: | :-----------: | :------------------------------------------------ | ----------- |
|   버블   |  O(n^2)  |  O(n^2)  |  비교, 교환   | 코딩이 가장 쉬움.                                 | 안정        |
|   선택   |  O(n^2)  |  O(n^2)  |  비교, 교환   | 교환의 횟수가 버블, 삽입보다 적음.                | 불안정      |
|   삽입   |  O(n^2)  |  O(n^2)  |  비교, 교환   | n의 개수가 적을 때 효과적.                        | 안정        |
|    퀵    | O(nlogn) |  O(n^2)  |   분할 정복   | 최악의 경우 O(n^2)이지만, 평균적으로는 가장 빠름. | 불안정      |
|   병합   | O(nlogn) | O(nlogn) |   분할 정복   | 연결 리스트의 경우 가장 효율적.                   | 안정        |
|  카운팅  |  O(n+k)  |  O(n+k)  |    비교환     | n이 비교적 작을 때만 가능.                        | 안정        |



 일단 위에 등장하지 않은 정렬에 대해서는 [여기](https://ratsgo.github.io/data%20structure&algorithm/2017/10/19/sort/)를 참고하며 공부하자.





**안정 vs. 불안정**

* 정렬 후에 기존의 순서가 보장되면 안정 정렬, 그렇지 않으면 불안정 정렬.
* 즉, **중복 값**이 있을 때, 그 중복된 값의 순서가 바뀌지 않으면 안정 정렬, 바뀌면 불안정 정렬이다.

| 초기 값           | 안정 정렬         | 불안정 정렬       |
| ----------------- | ----------------- | ----------------- |
| 2 5 1 *3* 4 **3** | 1 2 *3* **3** 4 5 | 1 2 **3** *3* 4 5 |

![stablenotstable]({{site.url}}/assets/images/stablenotstable.png){: width="50%" height="50%"}



**in-place 정렬**

* 입력 리스트 내부에서 정렬이 이루어지는 알고리즘.
* 정렬 도중 별도 저장 공간을 필요로 하지 않는다.





## 버블 정렬



* 인접한 두 원소를 비교하며 자리를 계속 교환하는 정렬 방식이다.
  * 모든 원소에 대해 **인접한 두 값을 비교**해서, 
  * **앞의 값이 뒤의 값보다 크면(혹은 작으면) 자리를 교환**한다. 
* 한 단계가 끝나면 가장 큰(혹은 작은) 원소가 제일 마지막 자리에 정렬된다.

![버블정렬]({{site.url}}/assets/images/Bubble-sort.gif){:.aligncenter}

<center><sup>이미지 출처 : https://www.fun-coding.org/Chapter12-bubblesorting.html</sup></center>



*예) 55 7 78 12 42를 오름차순으로 버블정렬하는 과정*

**정렬 원소** 미정렬원소

|      리스트       | 비교 대상 | 동작 |     정렬 결과     |
| :---------------: | :-------: | :--: | :---------------: |
|   55 7 78 12 42   |   55 7    | 교환 |   7 55 78 12 42   |
|                   |   55 78   | 유지 |   7 55 78 12 42   |
|                   |   78 12   | 교환 |   7 55 12 78 42   |
|                   |   78 42   | 교환 | 7 55 12 42 **78** |
| 7 55 12 42 **78** |   7 55    | 유지 | 7 55 12 42 **78** |
|                   |   55 12   | 교환 | 7 12 55 42 **78** |
|                   |   55 42   | 교환 | 7 12 42 **55 78** |
| 7 12 42 **55 78** |   7 12    | 유지 | 7 12 42 **55 78** |
|                   |   12 42   | 유지 | 7 12 **42 55 78** |
| 7 12 **42 55 78** |   7 12    | 유지 | 7 **12 42 55 78** |
| 7 **12 42 55 78** |     7     | 종료 | **7 12 42 55 78** |



### 코드 구현

* 바깥쪽 반복문에 의해 안쪽 반복문의 범위가 제어된다.
* 한 단계를 마치면 마지막에 정렬이 종료된 원소가 위차하므로, 단계를 거칠수록 정렬의 범위가 1씩 작아진다.

```python
def BubbleSort(a):
    for i in range(len(a)-1, 0, -1): 
        # reversed(range(len(a)))와 동일한 의미. 
        for j in range(0, i):
            if a[j] > a[j+1]: # swap
                a[j], a[j+1] = a[j+1], a[j]
     return a
```

* 반복문 범위 설정에 따라 다음과 같이 구현할 수도 있다. 위의 방식보다 이해가 조금 더 직관적이다.

```python
def BubbleSort(a):
    for i in range(len(a)): # 리스트의 크기만큼 아래 횟수 반복.
        for j in range(len(a)-1): # 각 단계별로 정렬이 끝나지 않은 원소들.
            if a[j] > a[j+1]:
                a[j+1], a[j] = a[j], a[j+1]
    return a
```



### 시간 복잡도

 평균적으로 **O(n^2)**의 시간 복잡도를 갖는다. 리스트 안에 n개의 원소가 존재할 때, 최악의 경우 (n-1) + (n-2) + ... + 1번 비교가 이루어진다.
