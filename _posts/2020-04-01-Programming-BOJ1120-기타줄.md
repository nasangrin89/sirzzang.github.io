---
title: "[백준] 기타줄"
excerpt: 1일 1문제풀이 13일차
header:
  teaser: /assets/images/blog-Programming.jpg
toc: true
categories:
  - Programming
tags:
  - BOJ
  - Python
  - Programming
  - 그리디

---





> [문제 출처](https://www.acmicpc.net/problem/1049)



# 1. 문제



Day Of Mourning의 기타리스트 강토가 사용하는 기타에서 N개의 줄이 끊어졌다. 따라서 새로운 줄을 사거나 교체해야 한다. 강토는 되도록이면 돈을 적게 쓰려고 한다. 6줄 패키지를 살 수도 있고, 1개 또는 그 이상의 줄을 낱개로 살 수도 있다.

끊어진 기타줄의 개수 N과 기타줄 브랜드 M개가 주어지고, 각각의 브랜드에서 파는 기타줄 6개가 들어있는 패키지의 가격, 낱개로 살 때의 가격이 주어질 때, 적어도 N개를 사기 위해 필요한 돈의 수를 최소로 하는 프로그램을 작성하시오.



**입력**

첫째 줄에 N과 M이 주어진다. N은 100보다 작거나 같은 자연수이고, M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에는 각 브랜드의 패키지 가격과 낱개의 가격이 공백으로 구분하여 주어진다. 가격은 0보다 크거나 같고, 1,000보다 작거나 같은 정수이다.



**출력**

첫째 줄에 기타줄을 적어도 N개 사기 위해 필요한 돈의 최솟값을 출력한다.



**입출력 예**

```python
입력
4 2
12 3
15 4

출력 : 12
```

```python
입력
10 3
20 8
40 7
60 4

출력 : 36
```

```python
입력
15 1
100 40

출력 : 300
```



---



# 2. 나의 풀이 



## 풀이 방법



 기타줄을 사는 경우의 수는 3가지가 있다.

* N개의 기타줄을 모두 낱개로 산다.
* N개의 기타줄을 패키지와 낱개로 맞추어 산다.
* N개 이상의 기타줄을 모두 패키지로 산다.



 위의 3가지 경우 중 가장 돈이 적게 드는 방법을 선택하면 된다. 

 주의할 것은 **패키지와 낱개를 모두 같은 가게에서 구매해야만 하는 것이 아니**라는 점이다. 질문 게시판을 보니 이 조건이 없는데도 불구하고, 해당 제약이 있다고 생각해 질문을 올린 사람이 많았다.



 

## 풀이 코드

* 두 번째와 세 번째 경우의 수를 구현하기 위해 `divmod` 함수를 사용했다.

  * 함수 실행 결과로 나오는 몫만큼 패키지를 사고, 나머지만큼 낱개를 사면 두 번째 경우가 된다.
  * 몫보다 1개 더 많은 수의 패키지를 사면 세 번째 경우가 된다.

  

```python
n, m = map(int, input().split())
prices = [list(map(int, input().split())) for _ in range(m)]

# 패키지 최소 가격, 낱개 최소 가격
package_min, single_min = min([p[0] for p in prices]), min([p[1] for p in prices])

q, r = divmod(n, 6)
cases = (n*single_min, q*package_min + r*single_min, (q+1)*package_min) # 구매 경우의 수

print(min(cases))
```



> *의문*
>
>  패키지와 낱개 가격의 순서쌍을 리스트로 만들어 리스트 안에 저장하고, 거기서 다시 최솟값을 구하는 방식을 적용했다.
>
>  문제를 풀면서도 효율성이 좋지 않을 것이라 생각했다.
>
> * 가격 인풋을 리스트에 담았다.
> * 최솟값을 구하기 위해 리스트 `min`함수와 리스트 컴프리헨션을 이용했다. 반복문이 돌아야 하는 작업이므로 어쨌든 비효율적이다. 
>
>  실제로 맞은 사람 목록 1페이지에 있는 풀이들이 모두 52ms가 소요된 반면, 내 풀이는 64ms가 소요된다.



---



# 3. 다른 풀이



[풀이 출처](https://www.acmicpc.net/source/10306071)

```python
n,m=map(int,input().split())
a,b=1000,1000
for _ in range(m):
	c,d=map(int,input().split())
	a,b=min(a,c),min(b,d)
print(n//6*min(a,b*6)+min(a,b*(n%6)))
```



  패키지와 가격의 최솟값을 각각 1000(문제 조건에서 최댓값이 1000이라고 했으므로)으로 설정해 놓고, **입력이 들어올 때마다** 그보다 작으면 *업데이트* 하는 방식을 사용하면 된다. 왜 풀 때는 생각해내지 못했나 싶다.

 경우의 수를 구하는 방법도 한 번에 구현했다.

* `n//6` : 구매해야 하는 패키지의 개수다. 이것을 패키지의 최솟값으로 묶어서 패키지만큼 구매하는 게 나은지, 낱개를 6개씩 묶어서 구매하는 게 나은지 판단한다.
* `min(a,b*(n%6))` : 패키지를 구매하는 방법을 결정하고 난 뒤, 남은 낱개를 어떻게 구매할 지 결정한다. `a`가 더 작다면 굳이 낱개로 모두 구매하지 말고 패키지를 하나 더 산다. 반대로 `a`가 더 크다면 낱개를 각각 구매한다.



 



---

# 4. 배운 점, 더 생각해 볼 점



*  굳이 사용할 필요가 없는 자료 구조를 사용하지 말자.
*  그리디 알고리즘 문제의 경우, 자료 구조를 사용해 저장하기보다는 최솟값 혹은 최댓값을 업데이트해나가는 방식이 더 효율적일 때가 많다.
*  코드에 반복문은 많으면 많을수록 좋지 않은 게 분명하다. 꼭 필요하지 않다면 반복하지 말자.