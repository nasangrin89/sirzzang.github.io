---
title: "[백준] RGB거리"
excerpt: 1일 1문제풀이 15일차
header:
  teaser: /assets/images/blog-Programming.jpg
toc: true
categories:
  - Programming
tags:
  - BOJ
  - Python
  - Programming
  - DP

---





> [문제 출처](https://www.acmicpc.net/problem/1149)



# 1. 문제



RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

- 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
- N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
- i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.



**입력**

첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.



**출력**

첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.



**입출력 예**

```python
입력
3
26 40 83
49 60 57
13 89 99

출력
96
```



---

# 2. 나의 풀이 



## 풀이 방법



 문제에서 주어진 규칙을 따라 첫 번째 집부터 세 번째 집까지 색깔을 선택하는 경우의 수를 나열하면 아래 사진과 같다.

![rgb거리]({{site.url}}/assets/images/boj1149.png)

<center><sup> 인덱스가 0부터 시작하기 때문에 0, 1, 2로 나타냈다.</sup></center>



  n번째 집에서 R을 칠하고 싶다면 이전 단계에서는 G나 B를 칠했어야 하고, G를 칠하고 싶다면 이전에는 R이나 B를, B를 칠하고 싶다면 이전에는 R이나 G를 칠했어야 한다.

 따라서 n번쨰 집에서 R을 칠할 때의 최소 비용은 **이전 단계**에서 G나 B를 칠했을 때의 **최소 비용에** n번째 집에서 R을 칠할 때 **비용을 더해 주면** 된다. G나 B를 칠하고 싶은 경우도 마찬가지다.

 

## 풀이 코드

* 집을 칠하는 비용을 모두 입력 받아 저장한다. 그리고 n번째 집에서 0번째 인덱스의 값을 n-1번째 집에서 1번째 인덱스 값과 2번째 인덱스 값의 최솟값에 현재 0번째 인덱스의 값을 더하는 방식으로 *업데이트* 했다.
* *두 번째 집부터만*  업데이트하면 된다.

> 29380KB, 64ms.

```python
import sys
s = sys.stdin.readline

N = int(s()) # 칠해야 할 집의 수
costs = [list(map(int, s().split())) for _ in range(N)] # n번째 집을 칠할 때 드는 비용 조합

for i in range(1, N):
    costs[i][0] += min(costs[i-1][1], costs[i-1][2])
    costs[i][1] += min(costs[i-1][0], costs[i-1][2])
    costs[i][2] += min(costs[i-1][0], costs[i-1][1])

# 마지막 집을 칠하는 최소 비용
print(min(costs[-1]) 
```





---



# 3. 다른 풀이



[풀이 출처](https://www.acmicpc.net/source/17883533)

> 29284KB, 52ms.

```python
import sys
read = sys.stdin.readline

n = int(read().strip())
dp = [list(map(int, read().strip().split()))]
for i in range(1, n):
    r, g, b = map(int, read().strip().split())
    nxt_r = r + min(dp[i-1][1], dp[i-1][2])
    nxt_g = g + min(dp[i-1][0], dp[i-1][2])
    nxt_b = b + min(dp[i-1][0], dp[i-1][1])
    dp.append([nxt_r, nxt_g, nxt_b])

print(min(dp[n-1]))

```



 다른 건 다 비슷한데, `nxt_r`, `nxt_g`, `nxt_b`를 활용해 최솟값을 갱신하고, 그걸 dp 수열에 append한다는 점이 내 풀이와 달랐다.  풀이 시간 상위권에 있는 풀이들이 모두 이런 방식이다.

 내 풀이에서는 한 번에 수열을 다 입력받아 놓고, 반복문을 돌면서, 심지어 반복문을 돌 때마다 인덱싱을 통해 접근해 들어가며 비용을 업데이트하는 것이라 시간이 오래 걸리는 듯하다. **인덱싱을 두 번이나 해야 하기 때문에 연산이 중복으로 이루어져야 한다.**

 



---

# 4. 배운 점, 더 생각해 볼 점



* 그리디 알고리즘과의 차이

  * 처음에 푼 풀이가 계속해서 틀렸다. 생각해 보니 처음 풀이는 그리디 방식의 풀이였다. 각 단계별로 1) 이전 단계에서 최소 비용을 구한 뒤, 2) 다음 단계에서는 이전 단계의 최소 비용을 제외하고 최소 비용을 구하는 방식이다.

  * 극단적으로 생각하면, 1번째 집에서 R을 칠하는 비용이 G보다 비쌌지만, 1번째 집에서 G를 칠하고 2번째 집에서 B를 칠하는 비용이나 G를 칠하고 R을 칠하는 비용이 1번째 집에서 R을 칠하고 B를 칠하는 비용보다 비쌀 수도 있다. 그리디 방식으로 최솟값만을 구해서 더해 나가면 안 된다는 의미다.

  * 이전 방식에서 푼 풀이는 다음과 같다.

    > 반례 : N = 2, [792, 926, 767], [545, 741, 257]

    

  ```python
  N = int(input())
  
  # 초기 설정
  costs = list(map(int, input().split()))
  min_c = min(costs)
  idx, money = costs.index(min_c), min_c
  
  # 이후 집들 색칠
  for _ in range(N-1):
      costs = list(map(int, input().split()))
      costs[idx] = 1001 # 이전에 사용한 색 사용 불가
      min_c = min(costs)
      idx = costs.index(min_c)
      money += min_c # 누적
  
  print(money)
  ```



* 코드로 구현하는 과정에서 이전 집의 최소 비용을 어떻게 구하나 고민했는데, 어차피 색깔이 3개밖에 안 되니까 인덱스를 사용하면 되는 일이었다. 사실 색깔이 많아도 상관은 없을 것 같은데, 풀고 나니 쓸데 없는 고민이었다!
* 다른 풀이들을 보고 나서 DP 문제 풀이의 방식에 대해 다시 깨달았다.  **DP 문제 풀이 핵심이 이전의 답을 기록해 놓고 그것을 활용한다는 점**임에 주목한다면, 나처럼 초기 입력을 모두 받아 놓고 업데이트하는 방식은 좋지 않다. 처음 입력만 받고(초기값) 그 단계에서 최소값을 기록해 나가는 방식으로 풀어야 한다.



